<html data-wf-domain="https://valor-software.com" data-wf-page="5df374d1014f24c851af97bf" data-wf-site="5c3f0ad89f55ca3a4f8c174c"><head><meta charset="utf-8"><title>JSON Web Token Authorization with Access and Refresh Tokens in Angular Application with Node.js Server</title><meta content="In this article, I want to teach you how to implement JSON Web Token (JWT) authorization with access and refresh tokens in your Angular app." name="description"><meta content="JSON Web Token Authorization with Access and Refresh Tokens in Angular Application with Node.js Server" property="og:title"><meta content="In this article, I want to teach you how to implement JSON Web Token (JWT) authorization with access and refresh tokens in your Angular app." property="og:description"><meta content="https://valor-software.com/assets/images/5f69bd89727b7bf38324bff7_art-3.jpg" property="og:image"><meta content="JSON Web Token Authorization with Access and Refresh Tokens in Angular Application with Node.js Server" property="twitter:title"><meta content="In this article, I want to teach you how to implement JSON Web Token (JWT) authorization with access and refresh tokens in your Angular app." property="twitter:description"><meta content="https://valor-software.com/assets/images/5f69bd89727b7bf38324bff7_art-3.jpg" property="twitter:image"><meta property="og:type" content="website"><meta content="summary_large_image" name="twitter:card"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://valor-software.com/assets/css/valor.5db4699e1.min.css" rel="stylesheet" type="text/css"><script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script><script type="text/javascript">WebFont.load({  google: {    families: ["Lato:100,100italic,300,300italic,400,400italic,700,700italic,900,900italic","Source Code Pro:regular"]  }});</script><!--[if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif]--><script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script><link href="https://valor-software.com/assets/images/5c811f6cd8195286971e9cb2_fav32.png" rel="shortcut icon" type="image/x-icon"><link href="https://valor-software.com/assets/images/5c811f71231350647fd8219d_fav256.png" rel="apple-touch-icon"><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-73071494-2"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-73071494-2', {'anonymize_ip': false});</script><!--Social media cover image-->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@ValorSoft">
<meta name="twitter:creator" content="@ValorSoft">
<meta property="og:image" content="https://valor-software.com/assets/images/5c9ca628202d433b51139d07_valor__soc.jpg">
<!-- Google console -->
<meta name="google-site-verification" content="V8GuXYLElkB-DyKBZ-F37ByQFJBrIwsT_v_N9kULChY">
<style>
/*Reset apple form styles*/
input, textarea, select { 
-webkit-appearance: none; 
-moz-appearance: none; 
appearance: none; border-radius: 0; 
background-image: none; }  
/*Remove legature for the font*/
* {
font-variant-ligatures: none;
}
</style>
<!--<meta name="google-site-verification" content="aKWCJbKr9azHpYeEU_4-omBBlky5cQKJgakGXnBcteU" />-->

<script>
  window.intercomSettings = {
    app_id: "brxsww1a"
  };
</script>
<script>
// We pre-filled your app ID in the widget URL: 'https://widget.intercom.io/widget/brxsww1a'
(function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',w.intercomSettings);}else{var d=document;var i=function(){i.c(arguments);};i.q=[];i.c=function(args){i.q.push(args);};w.Intercom=i;var l=function(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/brxsww1a';var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);};if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})();
</script><style>
/*Blog Highlight CSS*/
code, kbd, pre, samp {
    font-size: 0.8em !important;
    line-height: 1.6em !important;
}
.hljs {
    padding: 20px !important;
}
.rich-text h6 {
    word-wrap: break-word;
}
</style>
<!--Blog Highlight JS-->
<link rel="stylesheet" href="https://valor-software.com/assets/images/github.css">
<script charset="UTF-8" src="https://valor-software.com/assets/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></head><body><div data-collapse="medium" data-animation="over-left" data-duration="400" data-doc-height="1" data-easing="ease" data-easing2="ease" role="banner" class="navbar w-nav"><div class="container"><div class="nav"><a href="https://valor-software.com" class="brand w-nav-brand"><img src="https://valor-software.com/assets/images/5c595f3c4983ad4f7e7701c0_5c4ae3480900f7a7d3ce36d6_02-svg-valor-software-logo-white-text.svg" alt="Valor Software logo"></a><nav role="navigation" class="navbar__links w-nav-menu"><a href="https://valor-software.com/services.html" class="navbar__link">Services</a><a href="https://valor-software.com/clients.html" class="navbar__link">Clients</a><a href="https://valor-software.com/about.html" class="navbar__link">About</a><a href="https://valor-software.com/approach.html" class="navbar__link">Approach</a><a href="https://valor-software.com/careers.html" class="navbar__link">Careers</a><a href="https://valor-software.com/blog.html" class="navbar__link">Blog</a><a href="https://valor-software.com/contact.html" class="navbar__link">Contact</a><a rel="noreferrer" href="https://github.com/valor-software" target="_blank" class="nav__link w-inline-block"><img src="https://valor-software.com/assets/images/5c4f2b2edfbd6c3b9f281ea9_github.svg" width="40" height="40" alt="Github link" class="image-3"></a></nav></div><nav class="menu-btn w-nav-button"><div class="navbar_menu-icon w-icon-nav-menu"></div></nav></div></div><div style="background-image:url(&quot;https://valor-software.com/assets/images/5f69bd89727b7bf38324bff7_art-3.jpg&quot;)" class="header"><div class="container container__narrow"><div class="header__wrap"><h1 class="hero__heading hero__heading-blog">JSON Web Token Authorization with Access and Refresh Tokens in Angular Application with Node.js Server</h1><div class="auth__wrap"><a href="https://valor-software.com/persons/irina-ershova.html" class="author__link w-inline-block"><div class="auth__photo"><div style="background-image:url(&quot;https://valor-software.com/assets/images/5f69c1d7b804c9c0be07d513_ershova.jpg&quot;)" class="auth__photo-ava"></div></div><div class="auth__desc"><h2 class="blog-author__author-name">Irina Ershova</h2><h6 class="blog-author__role">JS Developer</h6></div></a></div><div class="art__date"><div class="auth__date">February 13, 2020</div><div class="translator__wrap"><div class="translator__prefix w-condition-invisible">Traduzido por</div><div class="translator__name w-dyn-bind-empty"></div></div></div></div></div><div class="p-header p-header--blue"></div></div><div class="section-w wf-section"><div class="container container__narrow"><div class="rich-text w-richtext"><p>Whenever we talk about web development and particularly web-application security, we can't walk past these two terms—<strong>authentication </strong>and <strong>authorization</strong>. In this article, I want to teach you how to implement JSON Web Token (JWT) authorization with access and refresh tokens in your Angular application. Since authorization also requires some server-side code, I’m going to implement the server functionality too so that we will have the whole context and see how all the parts work together.</p><p>Of course, JSON Web Token is not the only tool which you can use to add authorization to your application. I find this solution more self-contained and implemented faster than other common practices like session-based authentication. If you haven’t heard about JWT, I recommend you check out <a href="https://jwt.io/introduction/">the official page of JWT standard</a> before we switch to the implementation. In short, JWT is a string, which contains encrypted information about the authorized user, so we can avoid calling the service or database more than is necessary. For example, you can add such kinds of information to your token:</p><ul role="list"><li>User ID;</li><li>Email;</li><li>Username.</li></ul><p>That’s what we are going to do together!</p><p>Be aware that you shouldn’t store any sensitive data in the token like passwords or payment credentials because tokens are not fully encrypted. The server can simply read the user’s data from the JWT, without making any database lookups. We only need to inspect the token itself and validate the signature.</p><p>In addition, keep in mind that JWT tokens should have an expiration time and be renewable at certain intervals. It’s not obligatory, but it will protect your application when somebody steals the token and tries to get private data from the token over and over again.</p><p>Let’s look at the scheme to get a general understanding of how authorization with tokens works.&nbsp;</p><figure style="max-width:762pxpx" class="w-richtext-align-fullwidth w-richtext-figure-type-image"><div><img src="https://valor-software.com/assets/images/5e456e6a9522e72386a3d109_D-zJVfpIrJ-Ji17cz4XsxFhXbJ7M6u0l9t-0fnzVVEN_O9HqCLyb-kzVV9PD3VQepkw2G6MmVTIidM6kTZ_-qbQVrLppqWNrV0pue1FyXWgkgwdE1sjVb6ZFp8WM_hFEBmnwSc_5.png" alt=""></div><figcaption><em>Authorization with access and refresh tokens.</em></figcaption></figure><p>As you can see, the user receives both access and refresh tokens from the server. The access token is used each time we want to get protected data from our server, but usually developers send it with every request. You can do this using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">HTTP Authorization request header</a>.</p><p>The server is responsible for checking the user’s permission by using information, which is encrypted inside the access token. If the token is not expired and permission is valid, the server sends the requested data back to the client. Otherwise, the user receives an HTTP error of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401">401 Unauthorized</a>. In this case, the client sends a refresh token request.</p><p>The request that is responsible for updating the token has to contain the refresh token&nbsp; created during the user’s authorization. The server parses this token, and in case it’s valid, the system generates new access and refresh tokens, sends them back to the client, and failed requests are repeated. Under other conditions, the server sends back an error, and the user is redirected to the login page—not mandatory, but it is the most common practice.</p><p>After a brief description of JWT and the authorization process, we will implement this functionality step by step and investigate it more deeply through the following steps:&nbsp;</p><ul role="list"><li>Preliminary work: Configure the sample app;</li><li>Step 1: Create access and refresh tokens on the server;</li><li>Step 2: Send tokens to the client application;</li><li>Step 3: Create an HTTP interceptor;</li><li>Step 4: Check access via the token;</li><li>Step 5: Get the user data on page reload;</li><li>Step 6: Add functionality to refresh tokens.</li></ul><h2>Preliminary work: Configure the sample app</h2><p>I’ve already created a basic application for our little experiment. It consists of server and client parts. The client part is small and contains just three pages just to demonstrate the authorization for an Angular 8 application—a home page, a profile page, and a login page. The profile page is available only if users are logged in.<br><br></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://valor-software.com/assets/images/5e456e6e2fec8556e02f3341_T30FMx7gF5n-sSnAg81DpPmcLju5wKNKl5U0YeDyuuaAG4UZDqI9iL7VaM5kZuQ6WUSxzzgDLibThgVfo3fg7qZvbXBsRstL6L9epE3LUIE1Q-CwZPHPWGxE9jONVo_VivhLKd__.gif" alt=""></div></figure><p>Here is a list of technologies I’ve used for the application:</p><ul role="list"><li>Node.js 12.13.1;</li><li>NPM 6.12.1;</li><li>Angular 8.2.14;</li><li>Angular CLI 8.3.19;</li><li>Typescript 3.5.3;</li><li>Bootstrap 4.3.1.</li></ul><p><strong>Note</strong>: You can have other versions of packages, but it could affect some of the functionality.&nbsp;</p><p>The code, which we are using for the sample app, is available <a href="https://github.com/IraErshova/angular-authorization">on GitHub</a>. See the <a href="https://github.com/IraErshova/angular-authorization/blob/master/README.md">README.md file</a> for instructions on how to set up the application locally. You can check out the <strong>step-x </strong>(where <strong>x</strong> is the number of the step)<strong> </strong>branch if you want to work on the application in parallel with me alongside this article, or you can pull the <strong>master </strong>branch to use the code with the authorization already implemented.</p><p>As I’ve already mentioned, we have three pages, and the profile page contains sensitive data available for logged-in users only. The application sends HTTP requests to our server, which works with fake data. There is no database, and I just use the object to store user lists and information about user’s jobs in the <strong>data.mock.js</strong> file.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/server/data.mock.js">server/data.mock.js</a>&nbsp;</p><pre><code class="javascript">
exports.users = [{...}];
exports.jobs = [{...}];
</code></pre><p>‍<strong>Note</strong>: To log into the application, you can use any user from<strong> </strong>the <strong>data.mock.js</strong> file. There you can find usernames and passwords for each user.<br></p><p>When the user submits a form on the login page, the server checks the username and the password being sent. In case there’s a user on our list, we send the user’s information back to the client and save it to the <strong>user$</strong> property and local storage inside<strong> </strong>the <strong>auth.service.ts </strong>file. That’s how we can use the user’s information throughout the application. If you are not familiar with this syntax, don’t worry, you can implement this functionality in any way that is more suitable to you.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/client/src/app/services/auth.service.ts">client/src/app/services/auth.service.ts</a><br></p><pre><code class="javascript">
export class AuthService {
 user$ = new BehaviorSubject(null); constructor(private http: HttpClient) { } login(form: {username: string; password: string}): Observable&lt;User&gt; {
  return this.http.post&lt;User&gt;(`${environment.apiUrl}/login`, form)
   .pipe(
    tap(user =&gt; this.user$.next(user))
   );
 }
}
</code></pre><p>As you can see, we don’t have any token at this step, and basically, we don’t need it yet. The only problem is that we lose the user’s data after reloading the application in the browser. We are going to add corresponding functionality along with the token.</p><p>Right now, let’s look at the profile page more thoroughly because this page contains private data that we need to protect with Angular guard. If you don’t know how guards work, check <a href="https://angular.io/guide/router#milestone-5-route-guards">the official documentation</a>; there’s a helpful example there! We have AuthGuard, which checks if there is a logged-in user. If so, the navigation process continues. Otherwise, the user is redirected to the login page.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/client/src/app/services/auth.guard.ts">client/src/app/services/auth.guard.ts</a><br></p><pre><code class="javascript">
export class AuthGuard implements CanActivate {
 constructor(private authService: AuthService,
       private router: Router) { } canActivate(
  next: ActivatedRouteSnapshot,
  state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree {
  return this.authService.user$.pipe(
   map(user =&gt; !!user),
   tap(isLogged =&gt; {
    if (!isLogged) {
     this.router.navigateByUrl('/login');
    }
   })
  );
 }
}
</code></pre><p>AuthGuard protects the page from unauthorized access, but it doesn’t protect the server-side data. If you look at the profile component code, you’ll see the request, which is executed during component initialization. It gets the user’s job list. The request has a params object, which contains the user’s ID.&nbsp;</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/client/src/app/services/job.service.ts#L16">client/src/app/services/job.service.ts</a><br></p><pre><code class="javascript">
getJobList(userId: string): Observable&lt;Job[]&gt; {
 return this.http.get&lt;Job[]&gt;(`${environment.apiUrl}/job-list`, {
  params: {
   userId
  }
 });
}
</code></pre><p>Everybody who knows the user’s ID can repeat the request and get the private data—this is what we want to solve in this article. The access token is used in a token-based authorization to allow the client application to access the server’s data. As mentioned earlier, we receive access and refresh tokens after the user successfully authenticates and authorizes access. Then, we set the access token as HTTP Authorization header and send it with every request to our server. The token being passed informs the server that the bearer of the token has been authorized to access the server’s data.</p><p>So, without further ado, let's get started learning JWT-based Angular authorization!</p><h2>Step 1: Create access and refresh tokens</h2><p>First of all, let’s create a <strong>jwt.js</strong> file inside the server folder and add code there. The <strong>jwt.js</strong> file will be responsible for the functionality related to tokens. As I’ve already mentioned, we are going to use JWT, so we only need three things to create a token:</p><ul role="list"><li>A payload—the user’s data, which we want to encode;</li><li>A secret or private key;</li><li>The expiration time of the token.</li></ul><p>Tokens are generated on the server based on the secret key stored on the server and the payload. When a hacker tries to replace data in the payload, the token will become invalid because it won’t match the original value. Besides, the hacker doesn’t have an opportunity to generate a new token since the secret key for encryption is stored on the server. In our example, I added a secret key to the <strong>server.js</strong> file only, but it’s not good practice. You should always use the <strong>env</strong> variable for such data.</p><p>Since tokens are not fully encrypted information, we recommend not to store any sensitive data like passwords or payment credentials in them.</p><p>To make JSON web tokens work in the project, install the <a href="https://www.npmjs.com/package/jsonwebtoken">jwt library</a> as a dependency of the app (this part is already done) and import the module to the <strong>jwt.js </strong>file.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/server/jwt.js">server/jwt.js</a><br></p><pre><code class="javascript">
const jwt = require('jsonwebtoken');
const uuidv1 = require('uuid/v1');
const mockDB = require('./data.mock');
</code></pre><p>Let’s move on to the function of getting the access token. As you can see, the expiration time is only 15 minutes. After this time, the token will expire, and we will need to create a new one.&nbsp;<br></p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/server/jwt.js#L7">server/jwt.js</a><br></p><pre><code class="javascript">
function getAccessToken(payload) {
 return jwt.sign({user: payload}, jwtSecretString, { expiresIn: '15min' });
}
</code></pre><p>The function of getting the refresh token is a bit more complicated because we need to save it somewhere on the server. Usually, developers use <a href="https://redis.io/">Redis</a> to store refresh tokens, but they can also use any database they want, no strict rules there. In our case, we are going to use our fake database to store tokens. But be aware that if we reload the server, we will lose all this data.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-1/server/jwt.js#L11">server/jwt.js</a></p><pre><code class="javascript">
function getRefreshToken(payload) {
 // get all user's refresh tokens from DB
 const userRefreshTokens = mockDB.tokens.filter(token =&gt; token.userId === payload.id); // check if there are 5 or more refresh tokens,
 // which have already been generated. In this case, we should
 // remove all this refresh tokens and leave only new one for security reason
 if (userRefreshTokens.length &gt;= 5) {
  mockDB.tokens = mockDB.tokens.filter(token =&gt; token.userId !== payload.id);
 } const refreshToken = jwt.sign({user: payload}, jwtSecretString, { expiresIn: '30d' }); mockDB.tokens.push({
  id: uuidv1(),
  userId: payload.id,
  refreshToken
 }); return refreshToken;
}
</code></pre><p>I want you to look at the comments which I left for you inside the function. As you can see, before creating a new refresh token, we check how many refresh tokens the user has already had. But how is it possible that one user has multiple refresh tokens? Nowadays, people can use more than one device—smartphones, laptops, and tablets. That’s why we have to store all the refresh tokens for each user to use the authorization feature on more than one device. During each login, a record is created in our database. But, in that case, it’s worth taking care of security, that’s why I check the number of refresh tokens. The maximum number of tokens is five. If there are more than five, we have to delete all of them and keep only the new one. In this way, we can avoid a situation when someone tries to do sketchy stuff.<br></p><p><strong>Note:</strong> To make your authorization process more secure, you have to add an extra identifier to the tokens table. For example, it could be a <a href="https://en.wikipedia.org/wiki/Device_fingerprint">Browser fingerprint</a>. Browser fingerprinting allows websites to collect information about your browser type and version, your operating system, active plugins, timezone, language, screen resolution, and other various active settings. With this information, it will be almost impossible for the person who stole the token to refresh it without the correct browser fingerprint. But we don’t cover this part in the article.</p><p>At the end of the file, we have to export our functions to use them in any part of the server.</p><pre><code class="javascript">
module.exports = {
 getAccessToken,
 getRefreshToken
};
</code></pre><h2>Step 2: Send tokens to the client application</h2><p>Аfter you create the tokens, send them to the client application. If you want, you can switch to the <strong>step-2 </strong>branch to see implemented code or continue working in your current branch.&nbsp;</p><p>Let’s add this functionality to the server. First of all, we have to import our JWT service (<strong>jwt.js</strong>) to <strong>server.js </strong>and use its functions to get tokens.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-2/server/server.js#L16">server/server.js</a><br></p><pre><code class="javascript">
const jwtService = require('./jwt');…app.post('/login', function (req, res) {
 ...
 // Add tokens to request’s response const payload = {
  id : user.id,
  email: user.email,
  username: user.username
 };
 const accessToken = jwtService.getAccessToken(payload);
 const refreshToken = jwtService.getRefreshToken(payload); res.send({
  user,
  accessToken,
  refreshToken
 });
});
</code></pre><p>‍<strong>Note</strong>: Don’t forget to restart the server after you change code there, as there is no hot reload. If you really want to save some time, you can install <a href="https://nodemon.io/">nodemon</a> to restart your server automatically on changes.<br></p><p>Also, we need to update the login method in AuthService because the response was changed. Let’s inject <strong>LocalStorageService</strong> to the service and save tokens to the local storage.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-2/client/src/app/services/auth.service.ts#L20">client/src/app/services/auth.service.ts</a></p><pre><code class="javascript">
export class AuthService {
 user$ = new BehaviorSubject(null); constructor(private http: HttpClient,
       private localStorageService: LocalStorageService) { }login(form: {username: string; password: string}): Observable&lt;LoginResponse&gt; {
 return this.http.post&lt;LoginResponse&gt;(`${environment.apiUrl}/login`, form)
  .pipe(
   tap(response =&gt; {
    this.user$.next(response.user);
    this.setToken('token', response.accessToken);
    this.setToken('refreshToken', response.refreshToken);
   })
  );
}
private setToken(key: string, token: string): void {
 this.localStorageService.setItem(key, token);
}
</code></pre><p>Great! Let’s log in and check what’s in the local storage. The result should look like this:<br></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://valor-software.com/assets/images/5e456e6a9fe97358c72813ef_7GCuS1cbD_HahA8YFMkdU9pSjr-FUebYprhgkReozezZK40LXqzasa-MPAio_CUxUWnLi6VkfdoM6BZVHDVViAdvcdVn5aNAq31H_b-BYbwwyDseMAr7MDRHiXImdle3NfPFwht5.png" alt=""></div></figure><p></p><p>Also, don’t forget to remove tokens from the local storage on logout.&nbsp;</p><p><strong>Path: </strong><a href="https://github.com/IraErshova/angular-authorization/blob/step-2/client/src/app/services/auth.service.ts#L37">client/src/app/services/auth.service.ts</a><br></p><pre><code class="javascript">
logout(): void {
 this.localStorageService.removeItem('token');
 this.localStorageService.removeItem('refreshToken');
 this.user$.next(null);
}
</code></pre><p>Right now, we can add the HTTP Authorization header to all the requests, which we send to the server. The best tool for this is <a href="https://angular.io/api/common/http/HttpInterceptor">HttpInterceptor</a>.</p><h2>Step 3: Create an HTTP interceptor</h2><p>First of all, we have to create HttpInterceptor. Let's add <strong>token.interceptor.ts</strong> to the <strong>client/service</strong> folder. To set a new header, you need to get the access token from the local storage. In case the access token isn’t null, set the header. Otherwise, leave the request data untouched.&nbsp;</p><p><strong>Note</strong>: You can switch to the <strong>step-3 </strong>branch if you want to see the ready code.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/step-3/client/src/app/services/token.interceptor.ts">client/src/app/services/token.interceptor.ts</a>‍<br></p><pre><code class="javascript">
export class TokenInterceptor implements HttpInterceptor { constructor(private localStorageService: LocalStorageService) {} intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
  const accessToken = this.localStorageService.getItem('token');  return next.handle(this.addAuthorizationHeader(req, accessToken));
 }private addAuthorizationHeader(request: HttpRequest&lt;any&gt;, token: string): HttpRequest&lt;any&gt; {
 // If there is token then add Authorization header otherwise don't change    request
 if (token) {
  return request.clone({setHeaders: {Authorization: `Bearer ${token}`}});
 } return request;
}
}
</code></pre><p>Awesome! Let’s check our new functionality—log in and go to the profile page. In Devtools, in the Network tab, you can see a request for a job list. If you click on it, you’ll see more information about the request. If everything is correct, you’ll see our Authorization header in the Headers tab.<br></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://valor-software.com/assets/images/5e456e6af2cbe27e2f88d6f1_mYVaqA9S2g77V5DwY2sja-yotNBM2pJDALNDYSVigOqZYnt7sNHxd8B2eelr1SgU1BBVATuX_65zyAQ4suSOmxnpvxedaGtUCFFmkGgfr8wVHcUQ1R3qzTSdAnpJ_tjynPuL7C08.png" alt=""></div></figure><p></p><p>The next step is to implement a token check to verify access to the server data.</p><h2>Step 4: Check access via the token</h2><p>For starters, we create a function in <strong>jwt.js</strong>, which is going to return either user data or an error. I’m planning to wrap this functionality in <strong>Promise</strong>. You can switch to the <strong>step-4 </strong>branch to see ready code for this part or continue working on your branch.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/server/jwt.js#L33">server/jwt.js</a></p><pre><code class="javascript">
function verifyJWTToken(token) {
 return new Promise((resolve, reject) =&gt; {
  if (!token.startsWith('Bearer')) {
   // Reject if there is no Bearer in the token
   return reject('Token is invalid');
  }
  // Remove Bearer from string
  token = token.slice(7, token.length);  jwt.verify(token, jwtSecretString, (err, decodedToken) =&gt; {
   if (err) {
    return reject(err.message);
   }   // Check the decoded user
   if (!decodedToken || !decodedToken.user) {
    return reject('Token is invalid');
   }   resolve(decodedToken.user);
  })
 });
}
</code></pre><p>‍<strong>jwt.verify</strong> method has a callback that is called with the decoded payload if the signature and optional expiration, audience, or issuer are valid. If not, it will be called with an error. As you can see, the function returns decoded user’s data. This is done to use this data further in request methods, so we can avoid calling the database every time. Also, don’t forget to export this function.<br></p><p>Next, let’s use this function to add middleware to our routes, which require verification of access. Middleware functions give you access to the request (<strong>req</strong>) and response (<strong>res</strong>) objects and the <strong>next</strong> function in the application’s request-response cycle. <a href="https://expressjs.com/en/guide/writing-middleware.html">Read more about middleware</a>.</p><p>Middleware functions are also the perfect place to modify the req and res objects with relevant information and check user’s access. In our case, we can take the token and use it to fetch the user’s details from a database and store those details in<strong> res.user</strong>. Let’s add a new function to <strong>server.js</strong>, which is going to be our authorization middleware.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/server/server.js#L88">server/server.js</a></p><pre><code class="javascript">
function jwtMiddleware(req, res, next) {
 // get token from headers object
 const token = req.get('Authorization');
 // check token
 if (!token) {
  res.status(401).send('Token is invalid');
 } jwtService.verifyJWTToken(token)
  .then(user =&gt; {
   // put user's information to req object
   req.user = user;
   // call next to finish this middleware function
   next();
 }).catch(err =&gt; {
  res.status(401).send(err);
 });
}
</code></pre><p>In this function, we get the token from the request’s headers object and pass it as an argument to the <strong>verifyJWTToken </strong>function we just added. In case of error, we send 401 HTTP statuses and error messages. To apply our middleware function to the particular routes, we have to put it as an argument. Let’s check it with the request, which is responsible for getting the job list.<br></p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/server/server.js#L52">server/server.js</a><br></p><pre><code class="javascript">
app.get('/job-list', jwtMiddleware, function (req, res) {
 const jobList = mockDB.jobs.filter(job =&gt; job.user_id === req.user.id); res.send(jobList);
});
</code></pre><p>As you can see, I deleted the user ID, which I got from the request’s query.&nbsp;<br></p><pre><code class="javascript">
const userId = req.query.userId; // deleted code
</code></pre><p>Now replace it with the user ID from the <strong>req.user</strong> object. Do you remember that we created this property inside the <strong>jwtMiddleware</strong> function? In this way, we get rid of the user’s ID, which we send from the client. Now, no one can get the user’s job list event if they know the user's ID. That’s how the access token works.&nbsp;</p><p>Since we don’t need the user ID, we can delete params from the request. Let’s remove redundant code from <strong>JobService</strong>.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/client/src/app/services/job.service.ts">client/src/app/services/job.service.ts</a></p><pre><code class="javascript">
getJobList(): Observable&lt;Job[]&gt; {
 return this.http.get&lt;Job[]&gt;(`${environment.apiUrl}/job-list`);
}
</code></pre><p>It seems like everything already looks good except the refresh token functionality. But the small issue which we have to fix is the loss of the user’s data on page reload. Let’s correct this.<br></p><h2>Step 5: Get the user data on page reload</h2><p>If users log in and reload any page of our application in a browser, we need to redirect users to that page and keep them logged in. This will only happen if the access token is valid.&nbsp;</p><p>To implement this functionality, we need to get the user data from the client or, if there is no such data, but we have the token, fetch the token from the server. Let’s do this.</p><p><strong>Note</strong>: You can use the <strong>step-5</strong> branch.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/client/src/app/services/auth.service.ts#L43">client/src/app/services/auth.service.ts</a></p><pre><code class="javascript">
getCurrentUser(): Observable&lt;User&gt; {
 return this.user$.pipe(
  switchMap(user =&gt; {
   // check if we already have user data
   if (user) {
    return of(user);
   }   const token = this.localStorageService.getItem('token');
   // if there is token then fetch the current user
   if (token) {
    return this.fetchCurrentUser();
   }   return of(null);
  })
 );
}fetchCurrentUser(): Observable&lt;User&gt; {
 return this.http.get&lt;User&gt;(`${environment.apiUrl}/current-user`)
  .pipe(
   tap(user =&gt; {
    // save data to this.user$
    this.user$.next(user);
   })
  );
}
</code></pre><p>Look, we have a new request there—<strong>`${environment.apiUrl}/current-user`</strong>. Let’s add it to our server.</p><p><strong>Note:</strong> This request is similar to getting the job list request because it returns sensitive data. To receive user’s data, we need to have a valid token.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/server/server.js#L61">server/server.js</a></p><pre><code class="javascript">
app.get('/current-user', jwtMiddleware, function (req, res) {
 const currentUser = mockDB.users.find(user =&gt; user.id === req.user.id); res.send(currentUser);
});
</code></pre><p>The function is straightforward because we didn’t even have to get user data from the database; it’s already in <strong>req.user</strong> object. Therefore, the only thing left for us to do is to send this data.<br></p><p>Next, use this functionality in the root component. Since it doesn’t matter which page we reload, this request will always work. Can you guess which component we’re going to use? <strong>AppComponent</strong>, no doubt! Go to <strong>app.component.ts</strong> and change the following code:</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/client/src/app/app.component.ts#L22">client/src/app/app.component.ts</a><br></p><pre><code class="javascript">
ngOnInit(): void {
 this.user$ = this.authService.user$.pipe(share());
}
</code></pre><p>To:</p><pre><code class="javascript">
ngOnInit(): void {
 this.user$ = this.authService.getCurrentUser().pipe(share());
}
</code></pre><br><p>Great! You can check your application now. If you log in and reload it in the browser, you’ll still be authorized.</p><p>Finally, we are ready to move to our last step—implementing the refresh token functionality.</p><h2>Step 6: Add functionality to refresh tokens</h2><p>The last issue, which we are going to resolve, is refreshing the tokens. If you remember, our access token has an expiration time of only 15 minutes. It increases the security of the application. The token will become invalid 15 minutes after it’s created, and all the requests that have an authorization check will return a 401 HTTP error. To avoid this, we have to update the access token by using the refresh token so users could continue using the application without even noticing that something happened. Look at these steps:</p><ol role="list"><li><strong>jwtMiddleware</strong> check if the access token is still valid.</li><li>If the access token is invalid, the server sends a 401 HTTP error.</li><li>Add the refresh token functionality to our interceptor. It checks every HTTP error, which the client receives from the server.</li><li>In case the error has a 401 status, the client sends the request /refresh-token with the refresh token in the body (and a fingerprint if you have it).&nbsp;</li><li>The server looks for this refresh token in the DB, and in case there is no such token, we send a 403 HTTP error.</li><li>Otherwise, we check if the refresh token is valid (like it hasn’t expired and contains a correct signature). If the token is invalid, we send a 403 HTTP error.</li><li>If you have a fingerprint, you have to compare the current fingerprint with the one from the DB. If they are different, you have to send a 403 HTTP error.</li><li>In case all checks are valid, update this refresh token with a new one.</li><li>Create a new access token.</li><li>Send new tokens to the client.</li><li>Repeat failed requests.</li></ol><p><strong>Note</strong>: You can switch to the <strong>step-6 </strong>branch to view the ready code.</p><p>Steps 1 and 2 are already implemented. Let’s add the refresh token functionality to the server. First of all, we have to create a new post request.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/server/server.js#L67">server/server.js</a></p><pre><code class="javascript">
app.post('/refresh-token', function (req, res) {
 const refreshToken = req.body.refreshToken; if (!refreshToken) {
  return res.status(403).send('Access is forbidden');
 } try {
  const newTokens = jwtService.refreshToken(refreshToken, res);  res.send(newTokens);
 } catch (err) {
  const message = (err &amp;&amp; err.message) || err;
  res.status(403).send(message);
 }
});
</code></pre><br><p>As you can see, we have a new method there—<strong>jwtService.refreshToken</strong>. This method will check if our refresh token is valid and return new access and refresh tokens.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/server/jwt.js#L57">server/jwt.js</a><br></p><pre><code class="javascript">
function refreshToken(token) {
 // get decoded data
 const decodedToken = jwt.verify(token, jwtSecretString);
 // find the user in the user table
 const user = mockDB.users.find(user =&gt; user.id = decodedToken.user.id); if (!user) {
  throw new Error(`Access is forbidden`);
 } // get all user's refresh tokens from DB
 const allRefreshTokens = mockDB.tokens.filter(refreshToken =&gt; refreshToken.userId === user.id); if (!allRefreshTokens || !allRefreshTokens.length) {
  throw new Error(`There is no refresh token for the user with`);
 } const currentRefreshToken = allRefreshTokens.find(refreshToken =&gt; refreshToken.refreshToken === token); if (!currentRefreshToken) {
  throw new Error(`Refresh token is wrong`);
 }
 // user's data for new tokens
 const payload = {
  id : user.id,
  email: user.email,
  username: user.username
 };
 // get new refresh and access token
 const newRefreshToken = getUpdatedRefreshToken(token, payload);
 const newAccessToken = getAccessToken(payload); return {
  accessToken: newAccessToken,
  refreshToken: newRefreshToken
 };
}function getUpdatedRefreshToken(oldRefreshToken, payload) {
 // create new refresh token
 const newRefreshToken = jwt.sign({user: payload}, jwtSecretString, { expiresIn: '30d' });
 // replace current refresh token with new one
 mockDB.tokens = mockDB.tokens.map(token =&gt; {
  if (token.refreshToken === oldRefreshToken) {
   return {
    ...token,
    refreshToken: newRefreshToken
   };
  }  return token;
 }); return newRefreshToken;
}
</code></pre><p>I want you to pay attention to the <strong>getUpdatedRefreshToken</strong> function. You may wonder why I updated the old refresh token with a new one considering that every refresh token is valid for 30 days. It’s true. But in case somebody steals your refresh token, a hacker can also generate a new access token during these 30 days while the old token expires. To avoid this situation, and increase security, we are going to update the refresh token whenever we generate a new access token. But if the user is offline for more than 30 days, the user has to be authenticated again.&nbsp;</p><p>Let’s update our interceptor and add a refresh token request to AuthService. After getting a new token, don’t forget to save them in local storage:</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/client/src/app/services/auth.service.ts#L71">client/src/app/services/auth.service.ts</a><br></p><pre><code class="javascript">
refreshToken(): Observable&lt;{accessToken: string; refreshToken: string}&gt; {
 const refreshToken = this.localStorageService.getItem('refreshToken'); return this.http.post&lt;{accessToken: string; refreshToken: string}&gt;(
  `${environment.apiUrl}/refresh-token`,
  {
   refreshToken
  }).pipe(
   tap(response =&gt; {
    this.setToken('token', response.accessToken);
    this.setToken('refreshToken', response.refreshToken);
   })
 );
}
</code></pre><br><p>In the interceptor, we are going to work with a response. We have to check every response, which returns an error. In case you get a 401 HTTP error, update the tokens.</p><p><strong>Path:</strong> <a href="https://github.com/IraErshova/angular-authorization/blob/master/client/src/app/services/token.interceptor.ts">client/src/app/services/token.interceptor.ts</a><br></p><pre><code class="javascript">
intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
 const accessToken = this.localStorageService.getItem('token'); return next.handle(this.addAuthorizationHeader(req, accessToken)).pipe(
  catchError(err =&gt; {
   // in case of 401 http error
   if (err instanceof HttpErrorResponse &amp;&amp; err.status === 401) {
    // get refresh tokens
    const refreshToken = this.localStorageService.getItem('refreshToken');    // if there are tokens then send refresh token request
    if (refreshToken &amp;&amp; accessToken) {
     return this.refreshToken(req, next);
    }    // otherwise logout and redirect to login page
    return this.logoutAndRedirect(err);
   }   // in case of 403 http error (refresh token failed)
   if (err instanceof HttpErrorResponse &amp;&amp; err.status === 403) {
    // logout and redirect to login page
    return this.logoutAndRedirect(err);
   }
   // if error has status neither 401 nor 403 then just return this error
   return throwError(err);
  })
 );
}private logoutAndRedirect(err): Observable&lt;HttpEvent&lt;any&gt;&gt; {
 this.authService.logout();
 this.router.navigateByUrl('/login'); return throwError(err);
}private refreshToken(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
 if (!this.refreshingInProgress) {
  this.refreshingInProgress = true;
  this.accessTokenSubject.next(null);  return this.authService.refreshToken().pipe(
   switchMap((res) =&gt; {
    this.refreshingInProgress = false;
    this.accessTokenSubject.next(res.accessToken);
    // repeat failed request with new token
    return next.handle(this.addAuthorizationHeader(request, res.accessToken));
   })
  );
 } else {
  // wait while getting new token
  return this.accessTokenSubject.pipe(
   filter(token =&gt; token !== null),
   take(1),
   switchMap(token =&gt; {
    // repeat failed request with new token
    return next.handle(this.addAuthorizationHeader(request, token));
   }));
 }
}
</code></pre><p>Lastly, I want to draw your attention to the <strong>refreshToken </strong>method. You can see that there is a condition. We check whether refreshing has already started, set <strong>refreshingInProgress</strong> variable to true, and populate null into <strong>accessTokenSubject</strong> behavior subject. Then, we send a <strong>refreshToken</strong> request. In case of success, we set <strong>refreshingInProgress</strong> to false and place the access token we received into the <strong>accessTokenSubject</strong>. Finally, we call next.handle with a new Authorization header to repeat failed requests. In case the refreshing is already happening (the <em>else</em> part of the <em>if</em> statement), we want to wait until <strong>accessTokenSubject</strong> becomes <em>not null</em>. Once some value is emitted, we use <strong>take(1)</strong> to complete the stream and call <em>next.handle</em> to process the request.</p><p>If we get a 403 HTTP error, this means that the server couldn’t update your access token, and the user must be logged out.</p><h2>Conclusion</h2><p>In this article, we looked at such an important concept as authorization using JSON Web Token (JWT). JWT is overtaking the traditional session authorization for Angular applications by encrypting the user information and passing it back to the client.&nbsp;</p><p>We introduced you to principles of how JWT authorization works and implemented it step by step into <a href="https://github.com/IraErshova/angular-authorization">the sample app that you can always find on GitHub.</a></p><p>I hope that you got the picture of JWT authorization and its implementation and enjoyed the journey! If you have any questions, please leave comments and I will get back to you.&nbsp;</p><p>Thanks for reading!</p><p><br></p></div><div class="translator__wrap bottom"><div class="translator__prefix bottom w-condition-invisible">Traduzido por</div><div class="translator__name bottom w-dyn-bind-empty"></div></div></div></div><div class="section-sub wf-section"><div class="container container__narrow blog__alt"><h2 class="sub__header">Subscribe to find out more</h2><div class="form w-form"><form id="wf-form-Article-s-Subscribe-Form" name="wf-form-Article-s-Subscribe-Form" data-name="Article's Subscribe Form" method="get" class="art__form"><input type="email" class="sub__input w-input" maxlength="256" name="Email" data-name="Email" placeholder="Your e-mail" id="Email" required=""><input type="submit" value="Submit" data-wait="Please wait..." class="btn w-button"></form><div class="form__suc-bg w-form-done"><h3 class="sec__suc-2">Thank you!</h3><div> Your submission has been received!</div></div><div class="w-form-fail"><div>Oops! Something went wrong while submitting the form.</div></div></div></div></div><div class="section-art wf-section"><div class="container container__narrow"><h2 class="art__heading">More articles</h2><div class="w-dyn-list"><div role="list" class="row w-dyn-items"><div role="listitem" class="col art w-dyn-item"><a href="https://valor-software.com/articles/the-partnership-press-release-zack-jackson-and-valor-software.html" class="blog-card w-inline-block"><div style="background-image:url(&quot;https://valor-software.com/assets/images/624c9fb49d1b671b857dff61_Partnership_Release.png&quot;)" class="blog-card__img"></div><div class="blog-card__content"><h4 class="blog-card__heading">Announcing strategic partnership with Zack Jackson, the Module Federation inventor</h4><div class="blog-card__author"><div style="background-image:url(&quot;https://valor-software.com/assets/images/5fb3cfd99136afe1c0b815c0_evdokimenko.jpeg&quot;)" class="blog-card__author-photo"></div><div><div class="blog-card__author-name">Olga Ievdokymenko</div><div class="blog-card__author-role">Marketing Content Manager</div></div></div></div></a></div><div role="listitem" class="col art w-dyn-item"><a href="https://valor-software.com/articles/implementing-websockets-plugin-for-nativescript.html" class="blog-card w-inline-block"><div style="background-image:url(&quot;https://valor-software.com/assets/images/624495a97b77ab1729aaf5ad_Implementing_20WebSockets_20plugin_20for_20NativeScript_20using_20React_20Native.png&quot;)" class="blog-card__img"></div><div class="blog-card__content"><h4 class="blog-card__heading">Implementing WebSockets plugin for NativeScript using React Native</h4><div class="blog-card__author"><div style="background-image:url(&quot;https://valor-software.com/assets/images/61fbaf8cc1e0c9364b36bffa_Eduardo_Speroni_Valor-Software.jpeg&quot;)" class="blog-card__author-photo"></div><div><div class="blog-card__author-name">Eduardo Speroni</div><div class="blog-card__author-role">Angular Developer</div></div></div></div></a></div></div></div></div></div><div class="section-narrow section-narrow--red wf-section"><div class="container cta"><div class="cta__wrap"><div class="act__col"><h2 class="cta__header">Feeling inspired?<br></h2><p class="cta__desc">Let's discuss how Valor Software can help with your project's development needs!</p></div><div class="act__col"><a title="go to the contacts page" href="https://valor-software.com/contact.html" class="btn btn--inverted w-button">let's talk</a></div></div></div></div><div class="section-narrow section-narrow--dark wf-section"><div class="container"><div class="row footer"><div class="col footer__col"><div class="soc__item"><a rel="noreferrer" href="https://github.com/valor-software" target="_blank" class="w-inline-block"><img src="https://valor-software.com/assets/images/5c4f2b2edfbd6c3b9f281ea9_github.svg" width="40" height="40" alt="github icon"></a></div><div class="soc__item"><a rel="noreferrer" href="https://www.behance.net/ValorSoftware" target="_blank" class="w-inline-block"><img src="https://valor-software.com/assets/images/5c4f2b2edfbd6c9e41281ea8_behance.svg" width="40" height="40" alt="behance icon"></a></div><div class="soc__item"><a rel="noreferrer" href="https://www.facebook.com/valorsoftware/" target="_blank" class="w-inline-block"><img src="https://valor-software.com/assets/images/5c4f2b2ee97f83b6b33d3a3f_facebook.svg" width="40" height="40" alt="facebook icon"></a></div><div class="soc__item"><a rel="noreferrer" href="https://twitter.com/ValorSoft" target="_blank" class="w-inline-block"><img src="https://valor-software.com/assets/images/5c4f2b2ec49ea64ca2b3cee5_twitter.svg" width="40" height="40" alt="twitter icon"></a></div><div class="soc__item"><a rel="noreferrer" href="https://www.linkedin.com/company/valor-software/about/" target="_blank" class="w-inline-block"><img src="https://valor-software.com/assets/images/5c4f2b2ea29a8f6adcf1df87_linkedin.svg" width="40" height="40" alt="linkedin icon"></a></div></div><div class="col footer__col"><p class="footer__copyright">© 2020, Valor Software <br>All Rights Reserved</p></div></div></div></div><script src="https://valor-software.com/assets/js/jquery-3.5.1.min.dc5e7f18c8.js?site=5c3f0ad89f55ca3a4f8c174c" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="https://valor-software.com/assets/js/valor.62e147061.js" type="text/javascript"></script><!--[if lte IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif]--><!--Prevent zooming on mobile-->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">

</body></html>